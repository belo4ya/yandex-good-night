<details>
<summary> <b>Интернет</b> </summary>

<details>
<summary> HTTP, HTTPS </summary>

   HTTP (HyperText Transfer Protocol) - «протокол передачи гипертекста». 
   HTTP является протоколом прикладного (верхнего, 7-го) уровня модели OSI.
   
   Протокол HTTP предполагает использование клиент-серверной структуры передачи данных. 
   
   API многих программных продуктов также подразумевает использование HTTP для передачи 
   данных — сами данные при этом могут иметь любой формат, например, XML или JSON.
   
   Как правило, передача данных по протоколу HTTP осуществляется через TCP/IP-соединения. 
   Серверное программное обеспечение при этом обычно использует TCP-порт 80.

   HTTP сеанс:
   
   1. Установка TCP-соединения
   2. Запрос клиента
   3. Ответ сервера
   4. Разрыв TCP-соединения
   > протокол не хранит информацию о предыдущих запросах клиента
   и ответах сервера
   
   Структура HTTP запроса:
   
   - стартовая строка (GET /doc/test.html HTTP/1.1)
   - заголовки (Host: www.test101.com)
   - тело запроса (name=123&pass=123)
   
   Методы (глаголы) протокола:
    
   - GET (получение информации, стандартный запрос в браузере)
   - HEAD (GET без тела запроса)
   - POST (отправка данных на сервер)
   - PATCH (изменение данных на сервере)
   - DELETE (удаление данных с сервера)
   
   Коды ответов (статусы):
   
   - 1xx - информационный ответ (101 Switching Protocols)
   - 2xx - успешная обработка запроса (200 OK, 201 Created)
   - 3xx - перенаправления запроса (301 Moved Permanently, 302 Found)
   - 4xx - ошибка клиента (400 Bad Request, 403 Forbidden, 404 Not Found)
   - 5xx - ошибки сервера (500 Internal Server Error, 502 Bad Gateway)
   
</details>

</details>

---

<details>
<summary> <b>Базы данных</b> </summary>

<details>
<summary> Транзакции </summary>
    
   Транзакция - это последовательность операций, которая может быть полностью 
   выполнена либо полностью невыполнена. Но не наполовину.
   
   Транзакция долзна соответсвовать **требованиям ACID**:
   
   - **Атомарность**. Гарантирует, что транзакция будет полностью 
   выполнена или потерпит неудачу, где транзакция представляет 
   одну логическую операцию данных. Это означает, что при сбое 
   одной части любой транзакции происходит сбой всей транзакции 
   и состояние базы данных остается неизменным.
   
   - **Согласованность**. Гарантирует, что данные должны соответствовать 
   всем правилам валидации. Проще говоря, вы можете сказать, что ваша 
   транзакция никогда не оставит вашу базу данных в недопустимом состоянии.
   
   -**Изолированность**. Основной целью изолированности является контроль 
   механизма параллельного изменения данных.
   
   - **Долговечность**. Долговечность подразумевает, что если транзакция была подтверждена (COMMIT), 
   произошедшие в рамках транзакции изменения сохранятся независимо от того, что может 
   встать у них на пути (например, потеря питания, сбой или ошибки любого рода).
    
</details>

<details>
<summary> Индексы </summary>

   Индексы относятся к методу настройки производительности, 
   позволяющему быстрее извлекать записи из таблицы. Индекс 
   создает отдельную структуру для индексируемого поля и, 
   следовательно, позволяет быстрее получать данные.
   
   - Чаще всего по колонке с индексом строится сбалансированное 
   двоичное дерево. (log N операция сравнения)
   
   - Возможно построить составной индекс по нескольким полям.
   
   - Имеет значение порядок колонок в индексе.
   
   - Индекс замедляет изменение и занимает место.
   
   - Уникальный индекс (не позволяет полям иметь повторяющиеся значения), 
   кластеризованный индекс (изменяет физ. порядок таблицы. Только один кластеризованныый индекс), 
   некластеризованный индекс (не изменяет физический порядок таблицы и поддерживает логический порядок данных. 
   Каждая таблица может иметь много некластеризованных индексов).

</details>

<details>
<summary> Нормализация </summary>

   - Первая нормальная форма (1NF) — нет повторяющихся групп в строках
   
   - Вторая нормальная форма (2NF) — каждое неключевое (поддерживающее) 
   значение столбца зависит от всего первичного ключа
    
   - Третья нормальная форма (3NF) — каждое неключевое значение зависит только 
   от первичного ключа и не имеет зависимости от другого неключевого значения столбца

</details>

<details>
<summary> SQL типы соединений </summary>

   - **Inner join** (Внутреннее соединение): в MySQL является наиболее распространенным типом. 
   Оно используется для возврата всех строк из нескольких таблиц, для которых выполняется условие соединения.
   
   - **Left Join** (Левое соединение): в MySQL используется для возврата всех строк из левой (первой) 
   таблицы и только совпадающих строк из правой (второй) таблицы, для которых выполняется условие соединения.
    
   - **Right Join** (Правое соединение): в MySQL используется для возврата всех строк из правой (второй) 
   таблицы и только совпадающих строк из левой (первой) таблицы, для которых выполняется условие соединения.
   
   - **Full Join** (Полное соединение): возвращает все записи, для которых есть совпадение в любой из таблиц. 
   Следовательно, он возвращает все строки из левой таблицы и все строки из правой таблицы.

</details>

</details>

---

<details>
<summary> <b>Python</b> </summary>

`Типизация Python — динамическая сильная неявная`

<details>
<summary> 1. Базовые типы данных </summary>

   - Неизменяемые:
   ```int```, ```float```, ```complex```, ```str```, ```bytes```, ```None```, ```bool```, ```tuple```, ```frozenset```
   - Изменяемые:
   ```dict```, ```list```, ```set```
</details>

<details>
<summary> 2. Побитовые операции </summary>

   ```python
a = 120        # 1111000
b = 100        # 1100100
print(a | b)   # 124  = 0b1111100
print(a ^ b)   # 28   = 0b11100
print(a & b)   # 96   = 0b1100000
print(a << 4)  # 1920 = 0b11110000000
print(a >> 4)  # 7    = 0b111
print(~a)      # -121 = -0b1111001
   ```
</details>

<details>
<summary> 3. Функциональное программирование </summary>
   
   - ```lambda```, ```zip```, ```map```, ```filter```, ```reduce``` (functools)

   ```python
numbers = range(10)
squared_evens = map(lambda n: n ** 2, filter(lambda n: n % 2 == 0, numbers))
list(squared_evens)  # [0, 4, 16, 36, 64]
   ```

   - Декораторы:
   
   ```python
from functools import wraps
    
def logger(filename):

    def decorator(func):

        @wraps(func)
        def wrapped(*args, **kwargs):
            result = func(*args, **kwargs)
            with open(filename, "w+") as f:
                f.write(str(result))
            return result

        return wrapped

    return decorator
   ```
</details>

<details>
<summary> 4. Генераторы, выражения-генераторы, иттераторы </summary>

   - Генератор - это функция содержащая ключевое слово ```yield```.
   Генераторы позволят осуществлять ленивые вычисления. Также является иттератором.
   
   ```python
def fibonacci(number):
    a = b = 1
    for _ in range(number):
        yield a
        a, b = b, a + b
   ```

   - Выражения-генераторы предназначены для компактного и удобного способа генерации коллекций элементов.
   
   ```python
iter_ = (i ** 2 if i % 2 == 0 else i for i in range(5))  # <generator object <genexpr> at 0x000002D0E5219660>
list_ = [i ** 2 for i in range(10) if i % 2 == 0]  # [0, 4, 16, 36, 64]
set_ = {i for i in range(0, 10, 2)}  # {0, 2, 4, 6, 8}
dict_ = {v: k for k, v in {'a': 1, 'b': 2, 'c': 3}.items()}  # {1: 'a', 2: 'b', 3: 'c'}
   ```
   
   - Итератор — это сущность порождаемая функцией iter, с помощью которой происходит итерирование итерируемого объекта. 
   Итерируемый объект — это что-то, что можно итерировать. Итератор не имеет индексов и может быть использован только один раз.
   
   ```python
# реализация с помощью генераторов

def infinity(step):
    i = 0
    while True:
        yield i
        i += step

iter_ = infinity(10)
next(iter_)  # 0
next(iter_)  # 10
next(iter_)  # 20
   ```

   ```python
# итерируемый объект

class Arrange:

    def __init__(self, start, stop, step):
        self.i = start
        self.stop = stop
        self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        if self.i > self.stop:
            raise StopIteration

        result = self.i
        self.i += self.step
        return result
   ```
</details>

<details>
<summary> 5. ООП </summary>

   - Класс — это описание того, какими свойствами и поведением будет обладать объект. Объект — это экземпляр с собственным состоянием этих свойств.

   - Абстракция:
        - выделение главных, наиболее значимых характеристик предмета и отбрасывание второстепенных, незначительных.
   - Наследование:
        - позволяет описать новый класс на основе существующего (родительского). Повторное использование кода.
   - Полиморфизм
        - возможность работать с несколькими типами так, будто это один и тот же тип. При этом 
        поведение объектов будет разным.
   - Инкапсуляция
        - ограничение доступа к данным и возможностям их изменения путем сокрытия их в классе. (в python - договоренность)
</details>

<details>
<summary> 6. Магические методы (dunder методы) </summary>

   - [Специальные методы](https://docs.python.org/3/reference/datamodel.html#specialnames), с помощью которых можно добавить в ваши классы «магию». 
   Обрамлены двумя нижними подчеркиваниями. Некоторые из них:
   - Конструирование и инициализация:
        - `__new__(cls, [...)` - первый метод, который будет вызван при инициализации объекта для его создания.
        - `__init__(self, [...)` - инициализатор класса. Ему передаётся всё, с чем был вызван первоначальный конструктор.
        - `__del__(self)` -  определяет поведение объекта в то время, когда объект попадает в сборщик мусора.
   - Магические методы сравнения:
        - `__eq__(self, other)` - определяет поведение оператора равенства, ==.
        - `__ne__(self, other)` - определяет поведение оператора неравенства, !=.
        - `__lt__(self, other)` - определяет поведение оператора меньше, <.
        - `__gt__(self, other)` - определяет поведение оператора больше, >.
        - `__le__(self, other)` - определяет поведение оператора меньше или равно, <=.
        - `__ge__(self, other)` - определяет поведение оператора больше или равно, >=.
   - Унарные операторы и функции:
        - `__pos__(self)` - определяет поведение для унарного плюса (+some_object).
        - `__neg__(self)` - определяет поведение для отрицания(-some_object).
        - `__abs__(self)` - определяет поведение для встроенной функции abs().
   - Обычные арифметические операторы:
        - `__add__(self, other)` - сложение.
        - `__sub__(self, other)` - вычитание.
        - `__mul__(self, other)` - умножение.
   - Отражённые арифметические операторы:
        - `__radd__(self, other)` - отражённое сложение.
        - `__r...` - см. предыдущий пункт.
   - Составное присваивание:
        - `__iadd__(self, other)` - сложение с присваиванием.
        - `__i...` - см. пункт "Обычные арифметические операторы".
   - Магические методы преобразования типов:
        - `__int__(self)` - преобразование типа в int.
        - `__float__(self)` - преобразование типа в float.
        - `__complex__(self)` - преобразование типа в комплексное число.
        - `__oct__(self)` - преобразование типа в восьмеричное число.
        - `__hex__(self)` - преобразование типа в шестнадцатиричное число.
        - `__index__(self)` - преобразование типа к int, когда объект используется в срезах.
   - Представление своих классов:
        - `__str__(self)` - определяет поведение функции `str()`.
        - `__repr__(self)` - определяет поведение функции `repr()`.
        - `__hash__(self)` - определяет поведение функции `hash()`.
        - `__dir__(self)` - определяет поведение функции `dir()`.
        - `__sizeof__(self)` - определяет поведение функции `sys.getsizeof()`.
   - Контроль доступа к атрибутам:
        - `__getattr__(self, name)` - определяет поведение для случая, 
        когда пользователь пытается обратиться к атрибуту, который не существует.
        - `__setattr__(self, name, value)` - определяет поведение для присвоения значения атрибуту.
        - `__delattr__` - то же, что и __setattr__, но для удаления атрибутов, вместо установки значений.
   - Магия контейнеров:
        - `__len__(self)` - возвращает количество элементов в контейнере.
        - `__getitem__(self, key)` - определяет поведение при доступе к элементу, используя синтаксис `self[key]`.
        - `__setitem__(self, key, value)` - определяет поведение при присваивании значения элементу, 
        используя синтаксис `self[key] = value`.
        - `__delitem__(self, key)` - определяет поведение при удалении элемента (то есть `del self[key]`).
        - `__iter__(self)` - должен вернуть итератор для контейнера.
        - `__reversed__(self)` - вызывается чтобы определить поведения для встроенной функции `reversed()`.
        - `__contains__(self, item)` - предназначен для проверки принадлежности элемента с помощью `in` и `not in`.
        - `__missing__(self, key)` - определяет поведение , когда пользователь пытается получить 
        элемент по несуществующему ключу.
   - Вызываемые объекты:
        - `__call__` - означает, что `x()` означает то же, что и `x.__call__()`.
   - Менеджеры контекста:
        - `__enter__(self)` - определяет, что должен сделать менеджер контекста в начале блока, 
        созданного оператором `with`. Возвращаемое `__enter__` значение 
        и есть то значение, с которым производится работа внутри `with`.
        - `__exit__(self, ex_type, ex_value, tb)` - определяет действия менеджера контекста 
        после того, как блок будет выполнен.
   - Построение дескрипторов:
        - Дескрипторы это такие классы, с помощью которых можно добавить свою логику к событиям доступа 
        (получение, изменение, удаление) к атрибутам других объектов.
        - `__get__(self, instance, instance_class)` - определяет поведение при возвращении значения из дескриптора.
        - `__set__(self, instance, value)` - определяет поведение при изменении значения из дескриптора.
        - `__delete__(self, instance)` - определяет поведение для удаления значения из дескриптора.
   - Копирование:
        - `__copy__(self)` - определяет поведение `copy.copy()`.
        - `__deepcopy__(self, memodict={})` - определяет поведение `copy.deepcopy()`.
</details>

</details>

---

<details>
<summary><b> KISS, DRY, YAGNI, SOLID </b></summary>

<details>
<summary>KISS</summary>

Принцип проектирования **KISS(keep it simple stupid 
(keep it simple and straightforward))** провозглашает, что простота кода – 
превыше всего, потому что простой код – наиболее понятный. 
Принцип старается искать простые решения.

> Патерны проектирования описывают наиболее удачные, простые и понятные 
решения некоторых проблем. Если вы используете паттерн проектирования 
там, где нет проблемы, которую решает данный паттерн – то вы нарушаете 
KISS, внося ненужные усложнения в код. Если вы НЕ используете паттерн 
проектирования там, где есть проблема, соответствующая паттерну – то 
вы опять-таки нарушаете KISS, делая код сложнее, чем он мог бы быть.
</details>

<details>
<summary>DRY</summary>

**DRY – Don’t repeat yourself (не повторяй себя)**. 
Уменьшает сложность, разделяя систему на управляемые компоненты.

> Когда вы разрабатываете крупный проект, часто приходится сталкиваться 
с избыточной общей сложностью реализации. Люди плохо справляются с 
управлением сложных систем, им лучше удается находить необычные решения 
определенных задач. Самое простое решение по уменьшению сложности – 
разделить систему на мелкие, независимые модули, которыми проще управлять.
</details>

<details>
<summary>YAGNI</summary>

Принцип **«Вам это не понадобится» (YAGNI – you ain’t gonna need it)**. 
Что не задумано в системе, не должно появляться в коде. 
Уменьшает сложность, уменьшая количество компонентов системы.

> Если в бюджете не предусмотрена абстракция для БД – этой абстракции 
>не должно быть в системе. Если вдруг клиенту понадобится переехать 
>на другую БД, довольно очевидно, что это повлечет затраты на изменение системы.
</details>

<details>
<summary>SOLID</summary>

   #### Принцип единственной ответственности (Single Responsibility Principle):
   > Существует лишь одна причина, приводящая к изменению класса.
   
   Один класс должен решать только какую-то одну задачу. 
   Он может иметь несколько методов, но они должны использоваться 
   лишь для решения общей задачи. Все методы и свойства должны 
   служить одной цели. Если класс имеет несколько назначений, 
   его нужно разделить на отдельные классы.
   
   #### Принцип открытости/закрытости (Open-closed Principle)
   > Программные сущности должны быть открыты для расширения, но закрыты для модификации.

   Программные сущности (классы, модули, функции и прочее) должны быть расширяемыми 
   без изменения своего содержимого. Если строго соблюдать этот принцип, то можно 
   регулировать поведение кода без изменения самого исходника.
   
   #### Принцип подстановки Барбары Лисков (Liskov Substitution Principle)
   > 1. Предварительные условия не могут быть усилены в подтипе.
   > 2. Постусловия не могут быть ослаблены в подтипе.
   > 3. Инварианты супертипа могут быть сохранены в подтипе.

   Попросту говоря: подкласс/производный класс должен быть 
   взаимозаменяем с базовым/родительским классом. Значит, любая 
   реализация абстракции (интерфейса) должна быть взаимозаменяемой 
   в любом месте, в котором принимается эта абстракция.
   
   #### Принцип разделения интерфейса (Interface Segregation Principle)
   > Нельзя заставлять клиента реализовать интерфейс, которым он не пользуется.

   Это означает, что нужно разбивать интерфейсы на более мелкие, 
   лучше удовлетворяющие конкретным потребностям клиентов. Как 
   и в случае с принципом единственной ответственности, цель 
   принципа разделения интерфейса заключается в минимизации побочных 
   эффектов и повторов за счёт разделения ПО на независимые части.
   
   #### Принцип инверсии зависимостей (Dependency Inversion Principle)
   > Высокоуровневые модули не должны зависеть от низкоуровневых. 
   > Оба вида модулей должны зависеть от абстракций.

   > Абстракции не должны зависеть от подробностей. 
   > Подробности должны зависеть от абстракций.

   Применяя этот принцип, одни модули можно легко заменять другими, 
   всего лишь меняя модуль зависимости, и тогда никакие перемены в 
   низкоуровневом модуле не повлияют на высокоуровневый.
</details>

</details>
